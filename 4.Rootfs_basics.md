# Linux技术培训 - ROOTFS基础

## 目标

本章节通过一系列案例，为Linux应用程序开发人员普及基础的Kernel知识和概念，使之对Linux系统的底层原理和开发过程有个全局的认识。有利于未来开发项目时，更好地和内核开发工程师进行高效沟通。

## 参考资料

## 学习内容

### 内核态和用户态

请学习文章：用户态与内核态介绍<br>
<https://www.jianshu.com/p/85e931636f27>

简单来说，我们编译出来的Kernel只对应用程序提供一系列的系统调用API，而我们能调用、操作的Shell、所有命令、程序都运行在用户态，内核态是无法在Linux的shell里被用户直接访问到的。

用户态和内核态之间他们的内存是相互隔离的，不能互相访问，只能通过系统调用进行数据交换。<br>
不同用户态的程序看到的内存都是相互隔离的，不能互相访问，只能通过“进程间通讯”方式进行数据交换。

### 什么是ROOTFS

请学习文章：浅谈linux中的根文件系统<br>
<https://blog.csdn.net/LEON1741/article/details/78159754>

Linux系统由Kernel和Userspace两部分组成，分别构成了系统的内核态程序和用户态程序。<br>
Kernel我们已经在上一章中进行了编译和调试，本章我们讨论的rootfs就是系统Userspace程序。

### ROOTFS漫游

我们可以在开发板上，通过cd命令进入rootfs的各个一级目录下，看下都存在哪些文件。Linux的目录结构比较清晰，bin/sbin目录下都是可执行文件，/etc目录下都是配置文件，lib目录下都是库文件，/var/log下都是日志。

通过反复观察各个目录下的文件，找一下自己常用的命令分别在哪个目录下，可以对Linux Rootfs有个大概的了解，知道自己写的程序应该放在/usr/bin目录，网上下的开源库文件应该放在/usr/lib下……

同时我们可以对比一下BBB上的Arago-rootfs和开发机Ubuntu Linux系统的rootfs有什么区别，观察一下/bin、/usr/bin等目录，对比差异。

使用`du -h ~/rootfs`查看我们的rootfs有多大，这么多的文件如何在嵌入式设备里使用？这个问题我们留在下两节再来研究。

### /etc目录

/etc目录是Linux Rootfs的重要目录，存放了几乎所有系统程序的配置文件。

### busybox

### mount和挂载点

参考文章：

``` sh
root@am335x-evm:/bin# df -T
Filesystem           Type       1K-blocks      Used Available Use% Mounted on
# 这个是我们通过NFS挂载的rootfs
192.168.2.2:/home/cet/rootfs
                     nfs         41019616  21747132  17159104  56% /
# /dev目录下都是设备文件，硬件设备也是文件，这个目录是devtmpfs的挂载点
devtmpfs             devtmpfs      228496         4    228492   0% /dev
# tmpfs是一种内存文件系统即ramdisk；Linux的ramdisk不会在没有文件的时候实际占用物理内存
tmpfs                tmpfs         253584         0    253584   0% /dev/shm
tmpfs                tmpfs         253584      9596    243988   4% /run
tmpfs                tmpfs         253584         0    253584   0% /sys/fs/cgroup
tmpfs                tmpfs         253584         0    253584   0% /tmp
tmpfs                tmpfs          51200       700     50500   1% /var/volatile
tmpfs                tmpfs          16384         0     16384   0% /media/ram
# BBB上的eMMC有多个分区，文件系统也各不相同，他们分别被挂载到/run/media/xxxx目录下
/dev/mmcblk1p1       vfat           50396         1     50396   0% /run/media/mmcblk1p1
/dev/mmcblk1p2       squashfs       58112     58112         0 100% /run/media/mmcblk1p2
/dev/mmcblk1p4       ext4         2159860      6624   2023808   0% /run/media/mmcblk1p4
```

我们再来回顾一下我们的rootfs第一级目录结构，原来这些目录有些根本不是真实存在的文件目录，而是各类文件系统的挂载点，对其内部的文件访问会由内核映射到内核中的对应处理函数。
``` sh
bin
boot
dev         => devtempfs 内核中虚拟的设备文件系统
etc
home
init
lib
linuxrc
media
mnt
opt
proc        => procfs 内核提供的用于展示系统状态的虚拟文件系统
run         => tmpfs 是一个ramdisk
sbin
srv
sys         => sysfs 内核提供的用于控制系统的虚拟文件系统
tmp         => tmpfs 是一个ramdisk
usr
var
```

通过mount命令可以将存储设备挂载至某个挂载点，如：

``` sh
mkdir ~/tmpdir
# 挂载tmpfs文件系统至~/tmpdir
mount -t tmpfs -o size=20m tmpfs ~/tmpdir
# 卸载
umount ~/tmpdir

# 卸载系统已经挂载的procfs
umount /run/media/mmcblk1p4
ls /run/media/mmcblk1p4
# 新建一个维护home目录的emmc目录
mkdir ~/emmc
# 将刚才卸载的/dev/mmcblk1p4设备挂载到~/emmc目录
mount -t auto /dev/mmcblk1p4 ~/emmc
ls ~/emmc
# 显示系统挂载点
df -T
```

### 使用Buildroot制作rootfs


## 阶段测试

### 练习1：手动存储设备挂载

* 在/dev目录下查找eMMC的设备名，上网了解其命名规则。
* 使用mount、umount命令，将BBB上的eMMC各分区手动挂载至~/emmc/p1 ~/emmc/p2等目录下。
* 通过上网搜索，学习将最后一个分区，格式化为ext4文件系统。
* 修改Linux内核，将filesystem中ext4支持去掉，加载新内核后观察磁盘分区是否还能正常挂载

